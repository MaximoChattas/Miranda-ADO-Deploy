# Go
# Build your Go project.
# Add steps that test, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/go
# Template requirements: *.go and go.mod files in directory

trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
# Backend Directory
  backPath: '$(System.DefaultWorkingDirectory)/Backend'
  backDrop: 'golang-drop'
  
# Docker Images
  ResourceGroupName: 'MirandaProject'
  ConnectedServiceName: 'AzureResourceManager'
  acrLoginServer: "$(acrName).azurecr.io"
  acrName: 'MirandaACR'
  backImageName: 'employee-crud-api'
  backImageTag: 'latest'

# Azure App Services
  AppServicePlanLinux: 'MirandaASP'
  backAppServiceQA: 'chattas-backend-qa'


stages:
# -------------------------------------------------------------------------------
# |                 STAGE BUILD AND TEST FRONTEND AND BACKEND                   |
# -------------------------------------------------------------------------------
- stage: BuildAndTest
  displayName: 'Build And Test'
  jobs:
# -------------------------------------------------------------------------------
# |                        BUILD AND TEST API                                   |
# -------------------------------------------------------------------------------
  - job: BuildAndTestBack
    displayName: 'Build and Test Backend'
    steps:
    - task: GoTool@0
      inputs:
        version: '1.20'
    
    - task: Go@0
      displayName: 'Go mod init'
      inputs:
        command: custom
        customCommand: 'mod'
        arguments: 'init project'
        workingDirectory: '$(backPath)'

    - task: Go@0
      displayName: 'Go mod tidy'
      inputs:
        command: custom
        customCommand: 'mod'
        arguments: 'tidy'
        workingDirectory: '$(backPath)'
    
    - script: |
        go install github.com/jstemmer/go-junit-report@latest
        export PATH=$PATH:$(go env GOPATH)/bin
        go test -v ./... | go-junit-report > $(System.DefaultWorkingDirectory)/Backend/test-results.xml
      workingDirectory: '$(backPath)'
      displayName: 'Run tests and generate test report'


    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(backPath)/test-results.xml'
        failTaskOnFailedTests: true
      displayName: 'Publish test results'
      condition: always()
    
    - task: Go@0
      displayName: 'Go Build'
      inputs:
        command: 'build'
        workingDirectory: '$(backPath)'
    
    - task: ArchiveFiles@2
      displayName: 'Archive files'
      inputs:
        rootFolderOrFile: '$(backPath)'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactsStagingDirectory)/Backend/back-drop.zip
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        artifactName: '$(backDrop)'
        PathtoPublish: $(Build.ArtifactsStagingDirectory)/Backend
        publishLocation: 'Container'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish API Dockerfile'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/Dockerfile/Backend/Dockerfile'
        artifact: 'dockerfile-back'

# -------------------------------------------------------------------------------
# |     STAGE BUILD AND PUSH FRONTEND AND BACKEND DOCKER IMAGES TO ACR          |
# -------------------------------------------------------------------------------
- stage: DockerBuildAndPush
  displayName: 'Build and Push Docker Images to ACR'
  dependsOn: BuildAndTest
  jobs:
# -------------------------------------------------------------------------------
# |                        BUILD AND PUSH API                                    |
# -------------------------------------------------------------------------------
    - job: docker_build_and_push_api
      displayName: 'Build and Push API Docker Image to ACR'
      pool:
        vmImage: 'ubuntu-latest'
        
      steps:
        - checkout: self
        - task: DownloadPipelineArtifact@2
          displayName: 'Download API artifacts'
          inputs:
            buildType: 'current'
            artifactName: $(backDrop)
            targetPath: '$(Pipeline.Workspace)/$(backDrop)'
        
        - task: ExtractFiles@1
          displayName: 'Unzip API artifacts'
          inputs:
            archiveFilePatterns: '$(Pipeline.Workspace)/$(backDrop)/*.zip'
            destinationFolder: '$(Pipeline.Workspace)/Go-API'

        - task: DownloadPipelineArtifact@2
          displayName: 'Download API Dockerfile'
          inputs:
            buildType: 'current'
            artifactName: 'dockerfile-back'
            targetPath: '$(Pipeline.Workspace)/dockerfile-back'

        - task: AzureCLI@2
          displayName: 'Log in to Azure Container Registry (ACR)'
          inputs:
            azureSubscription: '$(ConnectedServiceName)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az acr login --name $(acrLoginServer)
        
        - script: ls -lR
          workingDirectory: $(Pipeline.Workspace)/$(backDrop)
    
        - task: Docker@2
          displayName: 'Build API Docker image'
          inputs:
            command: build
            repository: $(acrLoginServer)/$(backImageName)
            dockerfile: $(Pipeline.Workspace)/dockerfile-back/Dockerfile
            buildContext: '$(Pipeline.Workspace)/Go-API'
            tags: '$(backImageTag)'

        - task: Docker@2
          displayName: 'Upload API Docker image to ACR'
          inputs:
            command: push
            repository: $(acrLoginServer)/$(backImageName)
            tags: 'latest'

# -------------------------------------------------------------------------------
# |     STAGE DEPLOY FRONTEND AND BACKEND TO AZURE APP SERVICES QA              |
# -------------------------------------------------------------------------------
- stage: DeployImagesToAppServiceQA
  displayName: 'Deploy Docker Images to Azure App Service (QA)'
  dependsOn: 
  - BuildAndTest
  - DockerBuildAndPush
  condition: succeeded()
  jobs:
# -------------------------------------------------------------------------------
# |               DEPLOY API TO AZURE APP SERVICE                               |
# -------------------------------------------------------------------------------
    - job: DeployAPIImageToAppServiceQA
      displayName: 'Deploy API to Azure App Service (QA)'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: AzureCLI@2
          displayName: 'Create API Azure App Service resource and configure image'
          inputs:
            azureSubscription: '$(ConnectedServiceName)'
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              # Check if API App Service already exists
              if ! az webapp list --query "[?name=='$(backAppServiceQA)' && resourceGroup=='$(ResourceGroupName)'] | length(@)" -o tsv | grep -q '^1$'; then
                echo "API App Service doesn't exist. Creating new..."
                # Create App Service without specifying container image
                az webapp create --resource-group $(ResourceGroupName) --plan $(AppServicePlanLinux) --name $(backAppServiceQA) --deployment-container-image-name "nginx"  # Especifica una imagen temporal para permitir la creaci√≥n
              else
                echo "API App Service already exists. Updating image..."
              fi

              # Configure App Service to use Azure Container Registry (ACR)
              az webapp config container set --name $(backAppServiceQA) --resource-group $(ResourceGroupName) \
                --container-image-name $(acrLoginServer)/$(backImageName):$(backImageTag) \
                --container-registry-url https://$(acrLoginServer) \
                --container-registry-user $(acrName) \
                --container-registry-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)
